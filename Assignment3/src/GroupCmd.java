import java.util.ArrayList;import java.util.List;import java.util.Objects;import java.util.TreeMap;import java.util.HashSet;public class GroupCmd extends LibraryCommand {    /**     * All available GROUP command arguments.     */    private enum GroupCommandArgument {        TITLE,        AUTHOR    }    /**     * Name of the single digit group where are added the titles that start with a digit.     */    private static final String DIGIT_GROUP_NAME = "[0-9]";    /**     * Symbol prefixing the groups for titles and authors.     */    private static final String SYMBOL_PREFIXING_GROUPS = "## ";    /**     * Command argument that follows the GROUP command which is currently being executed.     */    private GroupCommandArgument commandArgument;    /**     * Create a group command.     *     * @param argumentInput Command argument.     * @throws IllegalArgumentException If given arguments are invalid.     * @throws NullPointerException     If the given argumentInput is null.     */    public GroupCmd(String argumentInput) {        super(CommandType.GROUP, argumentInput);    }    /**     * Execute the group command. This method evaluates if the user wants to group by title     * or author. The former groups all library entries by the starting letter of the title while     * the latter groups all entries by full author names. If there are multiple authors for a     * single title, the title for all of them is printed. Group names are ordered lexicographically,     * while the ordering within groups does not matter.     *     * @param data Book data to be considered for command execution.     * @throws NullPointerException     If data is null.     * @throws NullPointerException     If the loaded books are null.     * @throws IllegalArgumentException If the command argument is not as expected.     */    @Override    public void execute(LibraryData data) {        Objects.requireNonNull(data, ExceptionMessage.NULL_DATA.getExceptionMessage());        List<BookEntry> bookEntries = data.getBookData();        Objects.requireNonNull(bookEntries, ExceptionMessage.NULL_BOOK_ENTRIES.getExceptionMessage());        if (bookEntries.size() == 0) {            System.out.println("The library has no book entries.");        } else {            // TreeMap that will contain group names as keys and corresponding book titles as values            TreeMap<String, List<String>> groupMap;            // initialises groupMap depending on whether the user chose to group by title or author            switch (commandArgument) {                case TITLE:                    groupMap = createTitleMap(bookEntries);                    break;                case AUTHOR:                    groupMap = createAuthorMap(bookEntries);                    break;                default:                    throw new IllegalArgumentException(String.format("Given command argument" +                            " should be either TITLE or AUTHOR: %s", commandArgument));            }            // prints to the console the group output            groupPrint(groupMap);        }    }    /**     * Create the necessary TreeMap for grouping books by title.     *     * @param books List of books used to create the TreeMap.     * @return TreeMap containing group names as keys, and corresponding     * list of books that start with the same letter as the group name as values.     * @throws NullPointerException If books is null.     */    private TreeMap<String, List<String>> createTitleMap(List<BookEntry> books) {        Objects.requireNonNull(books, ExceptionMessage.NULL_BOOKS.getExceptionMessage());        TreeMap<String, List<String>> groupMap = new TreeMap<>();        HashSet<String> keys = new HashSet<>();        // iterates through the books, and adds the uppercase first letter of each book title to keys. If        // the title starts with a digit, then a single digit group name is added to keys        for (BookEntry book : books) {            if (book == null) {                continue;            }            String firstLetterUppercase = book.getTitle().substring(0, 1).toUpperCase();            if (!firstLetterUppercase.matches("\\d")) { //checks that firstLetterUppercase is not a digit                keys.add(firstLetterUppercase);            } else {                keys.add(DIGIT_GROUP_NAME);            }        }        // iterates through keys and adds every element in it as keys to groupMap        for (String key : keys) {            groupMap.put(key, new ArrayList<>());        }        // iterates through books and adds to groupMap every book as a value, depending on its first letter        for (BookEntry book : books) {            if (book == null) {                continue;            }            String firstLetterUppercase = book.getTitle().substring(0, 1).toUpperCase();            groupMap.get(firstLetterUppercase).add(book.getTitle());        }        return groupMap;    }    /**     * Create the necessary TreeMap for grouping books by author.     *     * @param books List of books used to create the TreeMap.     * @return TreeMap containing the different authors of the given list of books     * as keys, and the list of books written by the corresponding author as values.     * @throws NullPointerException If books is null.     */    private TreeMap<String, List<String>> createAuthorMap(List<BookEntry> books) {        Objects.requireNonNull(books, ExceptionMessage.NULL_BOOKS.getExceptionMessage());        TreeMap<String, List<String>> groupMap = new TreeMap<>();        // iterates through the books, then for every book iterates through its authors. If the author is not already        // a key of groupMap, then it gets added as one. Lastly the corresponding book title gets added to groupMap        for (BookEntry book : books) {            if (book == null) {                continue;            }            for (String author : book.getAuthors()) {                if (!groupMap.containsKey(author)) {                    groupMap.put(author, new ArrayList<>());                }                String title = book.getTitle();                groupMap.get(author).add(title);            }        }        return groupMap;    }    /**     * Print to the console the group output, no matter if the user chose to group     * the books by title or author.     *     * @param groupMap TreeMap needed to produce the group output, containing group     *                 names as keys and corresponding list of books as values.     * @throws NullPointerException If TreeMap is null.     */    private void groupPrint(TreeMap<String, List<String>> groupMap) {        Objects.requireNonNull(groupMap, "Given groupMap must not be null.");        StringBuilder consoleOutput = new StringBuilder();        consoleOutput.append("Grouped data by ").append(commandArgument);        // outer loop iterates through the keys and appends to consoleOutput the given symbol followed by the key        for (String key : groupMap.keySet()) {            consoleOutput.append("\n").append(SYMBOL_PREFIXING_GROUPS).append(key);            List<String> titles = groupMap.get(key);            // inner loop iterates through the list of titles of the key and appends to consoleOutput every title in it            for (String title : titles) {                consoleOutput.append("\n\t").append(title);            }        }        System.out.println(consoleOutput);    }    /**     * Parse the given command argument and assigns it to the instance variable.     *     * @param argumentInput Command argument that follows the group command, which     *                      specifies either TITLE or AUTHOR.     * @return True if the argument is a either AUTHOR or TITLE.     * @throws NullPointerException if the given argumentInput is null.     */    @Override    protected boolean parseArguments(String argumentInput) {        Objects.requireNonNull(argumentInput, ExceptionMessage.NULL_ARGUMENT.getExceptionMessage());        GroupCommandArgument commandArgument = parseGroupCommandArgument(argumentInput);        if (commandArgument == null) {            return false;        }        // checks if commandArgument is either AUTHOR or TITLE, and returns false if not        switch (commandArgument) {            case AUTHOR:            case TITLE:                break;            default:                return false;        }        this.commandArgument = commandArgument;        return true;    }    /**     * Translate given command keyword to corresponding GroupCommandArgument.     *     * @param inputArgument Command keyword.     * @return GroupCommandArgument associated with given keyword or null if no     * association was found.     */    private GroupCommandArgument parseGroupCommandArgument(String inputArgument) {        // iterates through the values of the enum, and returns the one which is associated with inputArgument        for (GroupCommandArgument argument : GroupCommandArgument.values()) {            if (argument.name().equals(inputArgument)) {                return argument;            }        }        return null; // returns null if no association has been found    }}